# ProcGrammar
Rule based Context sensitive Grammar for Procedural generation

Please have a look at src/sid/example/Main.java for the only example currently available.

## Introduction

Many text generation systems have a rule based system. for example:

```
start: $boy meets $girl.
boy: John, Charlie
girl: Gina, Charlotte
```

And it will generate sentences like "Charlie meets Gina" etc.

The system in this project attempts do something more complex. Usualy you cannot look back at the data generated and make decisions. This project helps you do that.

This is not a DSL, the rules must be Java code.

Defined rules first produce an object. A separate set of rules then take that object produce text out of it. The produced object might be interpreted differently by other modules instead, for example to draw an image.

## Examples

### Basic Examples

Rule names can be strings or Enums (actually can be any object but that is not recommended.)

```
Grammar g = new Grammar(new Context());
```

```
g.rule("A")
  .produces("B")
  .produces("C");
```
Rule A produces B or C with 50-50 chance.

```
g.rule("A")
  .produces("B").weight(2)
  .produces("C");
```
Rule A produces B or C with 66-33 chance. Weights can be any value, all weights are normalized into probabilities. A weight of 0 makes sure that rule will not be picked.

```
g.rule("object")
  .produces("color", "shape");
```
Rule 'object' calls rules 'color', then calls rule 'shape'. Both rules will be called in order.
This means rule 'object' decides the color and shape of the object.

```
g.rule("object")
  .produces("color").then("shape");
```
Same as above.

Please note none of the abocve generate any results, how to generate actual objects will be shown in a following section.

### Actally generating objects

The final result of firing the rules is a JSON-like object. It has a set of properties and every property has a set of values, which may themselves have properties and values.
```
Context ctx = new Context();
Grammar g = new Grammar();

// ... create rules here

g.rule("object").fire(ctx); // creates object 

System.out.println(ctx.root); // Print generated object

```

```
g.rule("chair").pushNode("chair") 
// Creates a new object, under property. All rules generated by this rule will now append values to that new object
  .produces("color").then("shape");
g.rule("color").pushNode("color").producesOneOf("red", "blue");
g.rule("shape").pushNode("shape").producesOneOf("square", "round");
```
Produces a chair which is red or blue, and square or round. Final object is:
```
{chair={color="red", shape="round"}}
```
